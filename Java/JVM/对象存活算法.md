---
title: 判断对象存活算法
date: 2018-03-01
categories: JVM
tags: [JVM,JAVA]
---
# 判断对象存活算法

## 引用计数法
> 给对象添加一个引用计数器，每当一个地方引用它时，引用计数器加1；引用失效时计数器减1；计数器为0表示对象不在被使用。

![alt text](/img/jvm/b9e5ecd5d1cfb1d045541c1f6e25e92c_hd.jpg "引用计数法")

- 缺点
  - 很难解决对象之间相互引用的方式

## 可达性分析算法
> 从GC Roots对象作为起始点，利用数学中图论知识，图中可达对象便是存活对象，而不可达对象则是需要回收的垃圾内存。

![alt text](/img/jvm/22f72b18415405c3e0207925a8de74fa_hd.jpg "可达性分析算法")

- GC ROOTS 对象
  - 虚拟机栈（栈帧的局部变量表）中所引用的对象；
  - 本地方法栈的JNI所引用的对象；
  - 方法区的类静态属性（static）和常量（static final）所引用的对象；

# 生存？死亡
>至少经过俩次可达性算法标记

- 第一次标记  根据是否有必要执行finalize()方法 在对象存活期只会调用一次
  - 没有必要执行：未覆盖finalize()方法或者已经调用
  - 有必要执行：将对象放入F-Quere队列中，虚拟机触发低优先级的finalize线程去执行，可由该方法再次拯救自己
- 第二次标记  F-Quere队列中对象进行第二次标记，若自救成功，在“即将回收”的集合中移除该对象

# 回收方法区
> 废弃常量和无用类

- 常量  没有其它地方引用这个字面量
- 类
  - 该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；
  - 加载该类的ClassLoader已经被回收；
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
